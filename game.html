<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Flappy Bird - Single File (Fixed)</title>
  <style>
    :root{
      --bg:#70c5ce;
      --ground:#de9e35;
      --pipe:#2ecc71;
      --text:#ffffff;
      --muted:rgba(255,255,255,0.9);
      --shadow: rgba(0,0,0,0.25);
    }

    html,body{
      height:100%;
      margin:0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: linear-gradient(#70c5ce 0%, #9ee0ea 100%);
      color:var(--text);
    }

    #game-wrap{
      max-width:700px;
      margin:32px auto;
      position:relative;
      box-shadow: 0 8px 30px var(--shadow);
      border-radius:12px;
      overflow:hidden;
    }

    /* Canvas is responsive -- sized via JS */
    canvas#game{
      display:block;
      width:100%;
      height:540px;
      background: linear-gradient(#70c5ce 0%, #9ee0ea 100%);
      cursor:pointer;
    }

    /* UI overlays */
    #ui{
      position:absolute;
      inset:0;
      pointer-events:none;
    }

    #title{
      text-align:center;
      font-weight:700;
      margin-top:12px;
      font-size:20px;
      text-shadow: 0 2px 0 rgba(0,0,0,0.2);
      pointer-events:auto;
    }

    #instructions{
      text-align:center;
      margin-top:4px;
      font-size:13px;
      color:var(--muted);
      pointer-events:auto;
    }

    #score{
      position:absolute;
      left:16px;
      top:16px;
      font-size:28px;
      font-weight:700;
      text-shadow: 0 2px 0 rgba(0,0,0,0.2);
      pointer-events:auto;
    }

    #message{
      position:absolute;
      left:50%;
      top:50%;
      transform:translate(-50%,-50%);
      background:rgba(0,0,0,0.45);
      padding:20px 24px;
      border-radius:8px;
      text-align:center;
      pointer-events:auto;
    }

    #message.hidden{ display:none; }

    #message-text{
      font-size:18px;
      margin-bottom:12px;
      color:#fff;
    }

    #restart{
      padding:8px 14px;
      font-size:14px;
      border-radius:6px;
      border:none;
      background:#ffd166;
      color:#000;
      cursor:pointer;
    }

    #footer{
      position:absolute;
      bottom:8px;
      left:0;
      right:0;
      text-align:center;
      font-size:12px;
      color:var(--muted);
      pointer-events:auto;
    }

    /* Simple mobile tweaks */
    @media (max-width:420px){
      canvas#game{ height:420px; }
      #score{ font-size:22px; }
    }
  </style>
</head>
<body>
  <div id="game-wrap">
    <canvas id="game"></canvas>

    <div id="ui">
      <div id="title">Flappy Bird</div>
      <div id="instructions">Click / Tap / Space to flap</div>
      <div id="score">0</div>
      <div id="message" class="hidden">
        <div id="message-text"></div>
        <button id="restart">Play again</button>
      </div>
      <div id="footer">Built with ❤️ — Press R to restart</div>
    </div>
  </div>

  <script>
    // Flappy Bird clone — improved spawn spacing and guaranteed openings
    (function () {
      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d');

      const scoreEl = document.getElementById('score');
      const message = document.getElementById('message');
      const messageText = document.getElementById('message-text');
      const restartBtn = document.getElementById('restart');

      // Device pixel ratio scaling for crisp rendering
      function resizeCanvas() {
        const rect = canvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        canvas.width = Math.max(320, Math.floor(rect.width * dpr));
        canvas.height = Math.max(240, Math.floor(rect.height * dpr));
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }

      // Game constants (tweakable)
      const GRAVITY = 0.45;
      const FLAP_STRENGTH = -7.8;
      const PIPE_SPEED = 2.6;
      const PIPE_WIDTH = 60;

      // The vertical gap will be computed relative to viewHeight for better scaling
      function computePipeGap(vh) {
        return Math.min(220, Math.max(100, Math.floor(vh * 0.22)));
      }

      // Horizontal spacing factor to guarantee consistent barrier distances
      const PIPE_SPACING_FACTOR = 0.58; // multiplied by viewWidth

      // State
      let bird = null;
      let pipes = [];
      let groundOffset = 0;
      let score = 0;
      let highScore = 0;
      let running = false;
      let gameOver = false;
      let lastFrame = 0;

      // Responsive logical size (used for drawing positions independently of pixel ratio)
      function viewWidth() { return canvas.getBoundingClientRect().width; }
      function viewHeight(){ return canvas.getBoundingClientRect().height; }

      // compute ground height consistently where needed
      function computeGroundHeight(vh) {
        return Math.max(28, vh * 0.12);
      }

      // Bird object
      function resetBird() {
        bird = {
          x: Math.round(viewWidth() * 0.25),
          y: Math.round(viewHeight() * 0.45),
          radius: Math.max(10, Math.min(18, viewHeight() * 0.04)),
          vel: 0,
          rotation: 0
        };
      }

      // Create a pipe pair (top and bottom). Optionally pass an x position (useful for initial fill).
      function spawnPipe(xPos) {
        const vw = viewWidth();
        const vh = viewHeight();
        const groundH = computeGroundHeight(vh);
        const PIPE_GAP = computePipeGap(vh);

        // Ensure a valid top height that guarantees the opening stays above ground and below ceiling
        const minTop = 16;
        const maxTop = Math.max(minTop, Math.floor(vh - groundH - PIPE_GAP - 16));
        const topHeight = Math.floor(minTop + Math.random() * (maxTop - minTop + 1));

        const x = (typeof xPos === 'number') ? xPos : (vw + PIPE_WIDTH + 8);
        const pipe = {
          x,
          top: topHeight,
          bottom: topHeight + PIPE_GAP,
          passed: false
        };
        pipes.push(pipe);
      }

      // Reset entire game
      function resetGame() {
        pipes = [];
        score = 0;
        running = false;
        gameOver = false;
        lastFrame = performance.now();
        resetBird();
        highScore = parseInt(localStorage.getItem('flappy_high') || '0', 10);
        hideMessage();
        scoreEl.textContent = score;

        // initial pipe fill with consistent spacing
        const vw = viewWidth();
        const spacing = Math.max(180, Math.floor(vw * PIPE_SPACING_FACTOR));
        // spawn a lead pipe a bit to the right and a few more spaced out
        const baseX = vw + PIPE_WIDTH + 8;
        for (let i = 0; i < 3; i++) {
          spawnPipe(baseX + i * spacing);
        }
      }

      // Input: flap
      function flap() {
        if (gameOver) return;
        bird.vel = FLAP_STRENGTH;
        running = true;
      }

      // Collision check between circle (bird) and rect (pipe)
      function circleRectCollision(cx, cy, r, rx, ry, rw, rh) {
        const closestX = Math.max(rx, Math.min(cx, rx + rw));
        const closestY = Math.max(ry, Math.min(cy, ry + rh));
        const dx = cx - closestX;
        const dy = cy - closestY;
        return dx * dx + dy * dy <= r * r;
      }

      function checkCollisions() {
        const vh = viewHeight();
        const groundH = computeGroundHeight(vh);
        const groundY = vh - groundH;

        // Ground collision: hitting the drawn ground area
        if (bird.y + bird.radius >= groundY) return true;
        if (bird.y - bird.radius <= 0) return true;

        // Pipes
        for (const p of pipes) {
          if (circleRectCollision(bird.x, bird.y, bird.radius, p.x, 0, PIPE_WIDTH, p.top)) return true;
          if (circleRectCollision(bird.x, bird.y, bird.radius, p.x, p.bottom, PIPE_WIDTH, vh - p.bottom)) return true;
        }
        return false;
      }

      // Drawing helpers
      function clear() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }

      function drawBackground() {
        const vw = viewWidth();
        const vh = viewHeight();

        ctx.save();
        ctx.globalAlpha = 0.12;
        ctx.fillStyle = '#ffffff';
        for (let i = 0; i < 3; i++) {
          const cx = ((performance.now() * (0.02 + i * 0.01)) % (vw + 300)) - 150;
          const cy = 40 + i * 30;
          ctx.beginPath();
          ctx.ellipse(cx, cy, 50 + i * 10, 20 + i * 6, 0, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.restore();
      }

      function drawPipes() {
        ctx.fillStyle = '#2ecc71';
        ctx.strokeStyle = '#1faa57';
        ctx.lineWidth = 2;
        const vh = viewHeight();

        for (const p of pipes) {
          // top
          ctx.beginPath();
          ctx.rect(p.x, 0, PIPE_WIDTH, p.top);
          ctx.fill();
          ctx.stroke();

          // bottom
          ctx.beginPath();
          ctx.rect(p.x, p.bottom, PIPE_WIDTH, vh - p.bottom);
          ctx.fill();
          ctx.stroke();

          // pipe caps
          ctx.fillStyle = '#27b765';
          ctx.fillRect(p.x - 6, Math.max(0, p.top - 6), PIPE_WIDTH + 12, 6);
          ctx.fillRect(p.x - 6, p.bottom, PIPE_WIDTH + 12, 6);
          ctx.fillStyle = '#2ecc71';
        }
      }

      function drawBird() {
        ctx.save();
        ctx.translate(bird.x, bird.y);
        ctx.rotate(bird.rotation);
        // body
        ctx.fillStyle = '#ffd166';
        ctx.beginPath();
        ctx.ellipse(0, 0, bird.radius, bird.radius * 0.8, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = 'rgba(0,0,0,0.08)';
        ctx.stroke();

        // eye
        ctx.fillStyle = '#333';
        ctx.beginPath();
        ctx.ellipse(bird.radius * 0.25, -bird.radius * 0.2, bird.radius * 0.2, bird.radius * 0.2, 0, 0, Math.PI * 2);
        ctx.fill();

        // beak
        ctx.fillStyle = '#ff6b6b';
        ctx.beginPath();
        ctx.moveTo(bird.radius * 0.9, 0);
        ctx.lineTo(bird.radius * 1.6, bird.radius * 0.1);
        ctx.lineTo(bird.radius * 1.6, -bird.radius * 0.1);
        ctx.closePath();
        ctx.fill();

        ctx.restore();
      }

      function drawGround() {
        const vh = viewHeight();
        const vw = viewWidth();
        const groundH = computeGroundHeight(vh);
        const y = vh - groundH;

        ctx.save();
        ctx.fillStyle = '#de9e35';
        ctx.fillRect(0, y, vw, groundH);

        ctx.fillStyle = '#c6842b';
        for (let i = -40 + (groundOffset % 40); i < vw; i += 40) {
          ctx.fillRect(i, y + groundH - 12, 20, 12);
        }
        ctx.restore();
      }

      // Main update loop
      function update(delta) {
        const vw = viewWidth();
        const vh = viewHeight();
        const spacing = Math.max(180, Math.floor(vw * PIPE_SPACING_FACTOR));
        const PIPE_GAP = computePipeGap(vh);

        if (!running) {
          // Idle bobbing effect while waiting to start
          bird.rotation = Math.sin(performance.now() / 450) * 0.08;
          return;
        }

        // Bird physics
        bird.vel += GRAVITY;
        bird.y += bird.vel;
        bird.rotation = Math.max(-0.6, Math.min(0.9, bird.vel * 0.06));

        // Pipes movement and scoring
        for (const p of pipes) {
          p.x -= PIPE_SPEED;
          if (!p.passed && p.x + PIPE_WIDTH < bird.x) {
            p.passed = true;
            score += 1;
            scoreEl.textContent = score;
            if (score > highScore) {
              highScore = score;
              localStorage.setItem('flappy_high', String(highScore));
            }
          }
        }

        // remove off-screen pipes
        pipes = pipes.filter(p => p.x + PIPE_WIDTH > -40);

        // spawn new pipe when last pipe has moved left enough to create spacing
        if (pipes.length === 0) {
          spawnPipe();
        } else {
          const last = pipes[pipes.length - 1];
          if (last.x < vw - spacing) {
            spawnPipe();
          }
        }

        // ground offset
        groundOffset += PIPE_SPEED;
        if (groundOffset > 1e6) groundOffset = 0;

        // Check collisions
        if (checkCollisions()) {
          endGame();
        }
      }

      function draw() {
        clear();
        drawBackground();
        drawPipes();
        drawBird();
        drawGround();
      }

      function loop(ts) {
        const delta = ts - lastFrame;
        lastFrame = ts;

        update(delta);
        draw();

        requestAnimationFrame(loop);
      }

      function showMessage(text) {
        messageText.textContent = text;
        message.classList.remove('hidden');
      }

      function hideMessage() {
        message.classList.add('hidden');
      }

      function endGame() {
        running = false;
        gameOver = true;
        showMessage('Game over — Score: ' + score + ' — High: ' + highScore);
      }

      // Event handlers
      function onPointerDown(e) {
        e.preventDefault();
        if (gameOver) {
          restart();
          return;
        }
        flap();
      }

      function onKeyDown(e) {
        if (e.code === 'Space') {
          e.preventDefault();
          if (gameOver) {
            restart();
            return;
          }
          flap();
        } else if (e.key.toLowerCase() === 'r') {
          restart();
        }
      }

      function restart() {
        resetGame();
        running = false;
        hideMessage();
      }

      // Setup listeners
      canvas.addEventListener('pointerdown', onPointerDown);
      window.addEventListener('keydown', onKeyDown);
      restartBtn.addEventListener('click', () => restart());

      // Handle resize
      let resizeTimer = null;
      function onResize() {
        resizeCanvas();
        resetBird();
        // rebuild pipes to match new layout/spacing
        pipes = [];
        // create initial fill after resize
        const vw = viewWidth();
        const spacing = Math.max(180, Math.floor(vw * PIPE_SPACING_FACTOR));
        const baseX = vw + PIPE_WIDTH + 8;
        for (let i = 0; i < 3; i++) {
          spawnPipe(baseX + i * spacing);
        }
      }
      window.addEventListener('resize', () => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(onResize, 120);
      });

      // Initialize
      function init() {
        resizeCanvas();
        resetGame();
        requestAnimationFrame(loop);
      }

      init();
    })();
  </script>
</body>
</html>
